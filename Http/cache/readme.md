# 缓存
1. 缓存位置
2. 缓存策略
3. 实际场景应用缓存策略


# 缓存位置
1. Service worker
2. Memory Cache
3. Disk Cache
4. Push Cache


- Service worker
运行在浏览器背后的独立线程，一般可以用来实现缓存功能，使用Service worker的话，传输协议必须是https，因为service worker中涉及了请求拦截。
Service worker实现缓存的三个步骤：首先需要注册Service Worker，然后监听到install事件以后就可以缓存需要的文件，在一下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话可以直接读取缓存文件，否则就去请求数据

- Memory Cache
内存中的缓存，读取内存中的数据比读取磁盘数据快，但是内存缓存虽然高效，可以缓存持续性很短，随着进程的释放（关闭tab页面）就会释放

对于大文件来说，大概率是不存储在内存中的，反之优先
当前系统内存的使用率高的话，文件会优先存进硬盘

- Disk Cache
硬盘缓存，虽然读取的速度慢了点，但是Disk Cache胜在容量大和存储的时效性高
他会根据HTTP Header中的字段判断哪些资源需要缓存，哪些资源可以不请求直接用，哪些资源已经过期需要重新请求

- Push Cache
当以上3种缓存都没有命中的时候，它才会被使用，并且缓存时间很短，只会在会话存在，一旦会话结束就被释放

# 缓存策略
1. 强缓存
2. 协商缓存

都是通过http header实现的

- 强缓存

可以设置http header 为：expires 或者 Cache-Control
只要是开启的强缓存的文件，在缓存期间是不需要请求的

Expires : wed, 22 , Oct, 2022, 08:12:00 GMT
表示资源会在上述时间后过期， 需要再次请求资源（受限于本地时间，如果修改本地时间，可能会造成缓存失效）

Cache-Control：Max-age=30
表示资源会在30秒后过期，需要再次请求

- 协商缓存

当强缓存到期了，就要发起请求验证资源是否有更新，如果没有更新，服务端返回304，那么直接更新强缓存的有效期
可以设置HTTP Header为：Last-Modified 或者 ETag
Last-Modified：表示本地文件最后一次修改的日期，当协商缓存执行时会询问服务器在该日期后是否有更新（缺点：只要本地打开了缓存文件，即使没有修改文件，也会找出Last-Modified被修改）

ETag：类似于文件的指纹，将ETag发送给服务端，询问资源的ETag有没有变动，没有的话就不更新


# 如果什么缓存策略都没有设置的话，浏览器会怎么处理？
浏览器会启用一个启发式算法，通常会取响应头中的Date减去Last-Modified的值的10%作为缓存时间

