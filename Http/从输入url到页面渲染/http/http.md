# http
1. 请求行
2. 首部
3. 实体


# 首部

- 通用首部
Cache-Control  控制缓存的行为
Date           创建报文的时间
Pragma         报文指令
Via            代理服务器的相关信息
Transfer       传输编码方式
Connection     浏览器想要优先使用的连接类型
User-Agent     客户端的信息

- 请求首部
Access         能正确接收的媒体类型
Access-Charset 能正确接收的字符集
Access-Encoding能正确接收的编码格式
Host           服务器的域名
Accept-Language能正确接收的语言

- 响应首部

Accept-Ranges  是否支持某些种类
Age            资源在代理缓存中存在的时间
Etag           资源标识
Location       客户端需要重定向去到某个url


# 实体
- 实体首部
Allow 资源的正确请求方式
Expires        内容过期时间
Content-type   内容的媒体类型
Last_Modified  内容最后修改时间

# 常见状态码
- 2xx 请求成功 
  200表示请求成功
  204表示请求成功，但是响应的报文不包含实体的主体部分
  205表示请求成功，但是响应的报文不包含实体的主体部分，但是要求请求方重置内容
- 3xx 重定向
  
- 4xx 客户端错误
- 5xx 服务端错误
  500 服务器请求时发生的错误
  501
  503

# TSL 协议
HTTPS还是通过HTTP协议来传输信息，但是信息通过TLS协议进行了加密

TLS有两种方式：
1. 对称加密
2. 非对称加密

- 对称加密：客户端和服务端两边具有相同的秘钥，两边都直达如何将密文进行加密和解密，这种方式很方便，但是问题在于，如何让双发都知道秘钥，因为传输数据用的是网络，如果将秘钥通过网络从方式进行传递的话，一旦秘钥被捕获，那就没有加密的意义了

- 非对称加密：有公钥和私钥之分，公钥可以让所有人知道，用于数据加密，但是要解密数据必须使用私钥，私钥只有分发公钥的一方知道

- 流程： 假如A是服务端，B是客户端
  1. A创建公钥和私钥，将公钥公布出去让B知道
  2. B创建一个秘钥，然后通过公钥加密这个秘钥并发送给A
  3. A通过私钥解密这个秘钥
  4. 两端就都具备秘钥了


# HTTP3
1. http1中存在一些性能问题，因为浏览器限制了同一个域名下的请求数量（chrome一般是6个），如果一个页面需要大量的请求，那么就会造成请求阻塞，需要前6个请求完，才能请求下一波的6个
2. http2解决了这些性能问题，引入了多路复用（一个TCP连接可以传输多条数据流），采用二进制编码，大幅提升了网络性能，又因为使用多路复用，当某个TCP连接出现丢包的情况，就会导致http2的情况更复杂，反倒不如HTTP1了
3. http3基于udp协议里面的quic协议，解决了tcp的问题


# post 和 get 的区别？
副作用：服务器上的资源发生改变
幂等：服务器上的资源状态是否一致

1. 从应用场景来说：get多用于无副作用，幂等的场景，比如搜素关键字，post多用于副作用，不幂等的场景，比如注册
2. get请求能缓存，post不能
3. post相对get稍微安全一点，因为get请求的参数都包含在url中（body），并且会被浏览器保存历史记录，post不会
4. 因为浏览器对url有长度限制，所以会影响get请求
5. post支持更多的编码类型，且不对数据类型做限制




# 从输入url到页面渲染发生了什么
1. 客户端DNS解析，得到服务器IP地址
2. TCP的三次握手，建立连接
3. 发起http请求，进行数据传输
4. 浏览器获取到html，css，js这种资源
5. TCP的四次挥手，释放连接
6. 浏览器会将 html 解析成为DOM树，CSS解析成为CSSOM树，再合并成为Render树
7. 拿着render树去调用浏览器的GUI 绘图功能，绘制出页面（回流重绘）