# UDP

UDP 和 TCP的区别是什么？
1. UDP协议是面向无连接的，也就是说不需要在正式传递数据之前先建立双方的连接。
2. UDP只是数据报文的搬运工，不保证有序且不丢失的传递到对面
3. UDP没有任何控制流量的算法

- 面向无连接
不需要在发送数据之前进行三次握手，想发数据就可以发送，不会对数据报文进行任何的拆分和拼接

发送端（数据）： 应用层 -> 传输层 (UDP 只会给数据增加一个UDP 头标识) -> 网络层
接收端 -> 网络层（得到数据） -> 传输层（去除头标识） -> 应用层

- 不可靠性
体现在无连接，想发就发
接受到什么数据就传递什么，不会备份数据，也不会关心对方是否已经正确的接受到了数据
没有拥塞控制，一直以恒定的速度发送数据，网络条件不好的时候，可能会造成数据包丢失


- 高效
UDP 的头部开销小，只有8字节，而TCP至少有20字节

- 应用场景

直播，视频通话，实时性游戏


# TCP
1. 传输之前需要建立连接
2. 通过各种算法保证数据的有序且可靠传输
3. 有拥塞控制
  
（聊到了TCP有20个字节的头部时，面试官会问：TCP的头部包含哪些字段：
   1. Sequence number：序号，保证了数据报文都是有序的，接受端可以通过序号顺序拼接报文
   2. Acknowledgement number: 该序号表示接收端期望接受的下一个字节的编号是多少，同时也表示上一个数据已经接受到的
   3. window size：窗口大小，表示还能接受多少字节的数据，用于流量控制
   4. 标识符：
        URG = 1：表示当前的数据包是紧急数据，那么该数据包一定会位于当前传输的数据包的最前面
        ACK = 1：表示当前数据有效
        PSH = 1：表示接受端应该立即把当前的数据包交给应用层，而不是等到缓存区存满再提交
        RST = 1：表示当前的TCP连接出现了严重问题，可能需要重新请求报文
        SYN = 1：当SYN = 1，ACK=0，表示当前报文段是一个请求报文；当SYN=1，ACK=1，表示当前报文段式一个统一建立连接的应答报文
        FIN = 1：表示当前报文段是一个释放连接的请求
  ）

## TCP三次握手
1. 客户端向服务端发送连接请求报文，该报文中包含自身的数据通讯初始序号，请求发送之后，客户端便进入Syn-Sent状态；
2. 服务端接收到连接请求报文后，如果同意连接，则会发送一个应答，该应答中包含自身的数据通讯初识序号，发送完后便进入Syn-Recrived状态
3. 客户端收到连接应答后，还要想服务端发送一个确认收到应答的报文，客户端便进入Established，服务端接受到此次应答后也进入Established状态


## 为什么TCP建立连接后需要三次握手，明明两次就可以建立连接
假设客户端发送连接请求A，但是因为网络原因造成了超时，这时TCP会启动超时重传机制，重新发一个连接请求B，此时请求B顺利到达服务端，服务端应答完成建立了连接，然后接受数据完成后断开了连接。假设这时请求A在两端关闭后又抵达了服务端，那么此时服务端会认为客户端又需要建立连接，从而应答该请求进入Syn-Received状态，但是客户端其实是close状态，那么服务端就会一直等待，造成资源浪费

## tcp四次挥手
1. 客户端向服务端发送连接释放请求
2. 服务端接收到连接释放请求后，会告诉应用层要释放TCP连接，然后应答该连接释放请求，服务端进入close_wait状态，此时服务端不在接收客户端发送的数据了，【但是此时服务端仍然可以向客户端发送数据了】
3. 如果服务端还没发完数据，会继续发送，完毕后会向客户端发送连接释放请求，自己便进入Last_Ack状态
4. 客户端接收到释放请求后，向服务端发送应答确认，此时客户端进入Time_wait状态，该状态会持续2MSL（报文在网络中生存的最大时间）时间，若该时间段内没有服务端的请求，就会进入CLOSED状态，服务端接收到应答后也会进入CLOSED状态


# 为什么客户端要进入TIME_Wait状态，等待2MSL时间才进入CLOSED状态
为了保证服务端能收到客户端的确认应答，如果客户端直接进入closed状态，最后的确认应答万一因为网络问题没有送达，那么就会造成服务端不能正常关闭