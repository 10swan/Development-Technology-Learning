---
highlight: a11y-dark
---
# 前言
当用户高频触发某一事件时，如窗口的resize、scroll，输入框内容校验等，此时这些事件调用函数的频率如果没有限制，可能会导致响应跟不上触发，出现页面卡顿，假死现象。此时，我们可以采用 **防抖(debounce)** 和 **节流(throttle)** 的方式来减少调用频率，同时又不影响实际效果。
# 防抖
假设你用手压住一个弹簧，那么弹簧不会弹起来，除非你松手。

函数防抖，就是指触发事件后，函数在 n 秒后只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数的执行时间。

> 简单的说，当一个函数连续触发，只执行最后一次。

函数防抖一般用在什么情况之下呢？一般用在，连续的事件只需触发一次回调的场合。具体有：
1.  搜索框搜索输入。只需用户最后一次输入完，再发送请求；
1.  用户名、手机号、邮箱输入验证；
1.  浏览器窗口大小改变后，只需窗口调整完后，再执行resize事件中的代码，防止重复渲染。
## 代码实现
在下面这段代码中，我们实现了最简单的一个防抖函数，我们设置一个定时器，你重复调用一次函数，我们就清除定时器，重新定时，直到在设定的时间段内没有重复调用函数。
```js
// fn是你要调用的函数，delay是防抖的时间
function debounce(fn, delay) {
  // timer是一个定时器
  let timer = null;
  // 返回一个闭包函数，用闭包保存timer确保其不会销毁，重复点击会清理上一次的定时器
  return function () {
    // 调用一次就清除上一次的定时器
    clearTimeout(timer);
    // 开启这一次的定时器
    timer = setTimeout(() => {
      fn();
    }, delay)
  }
}
```
## 代码优化
仔细一想，上面的代码是不是有什么问题？

**问题一：** 我们返回的fn函数，如果需要事件参数e怎么办？事件参数被debounce函数保存着，如果不把事件参数给闭包函数，若fn函数需要e我们没给，代码毫无疑问会报错。

**问题二：** 我们怎么确保调用fn函数的对象是我们想要的对象？你发现了吗，在上面这段代码中fn()函数的调用者是fn所定义的环境，这里涉及this指向问题，想要了解为什么可以去了解下js中的this。

为了解决上述两个问题，我们对代码优化如下

```js
// fn是你要调用的函数，delay是防抖的时间
function debounce(fn, delay) {
  // timer是一个定时器
  let timer = null;
  // 返回一个闭包函数，用闭包保存timer确保其不会销毁，重复点击会清理上一次的定时器
  return function () {
    // 保存事件参数，防止fn函数需要事件参数里的数据
    let arg = arguments;
    // 调用一次就清除上一次的定时器
    clearTimeout(timer);
    // 开启这一次的定时器
    timer = setTimeout(() => {
      // 若不改变this指向，则会指向fn定义环境
      fn.apply(this, arg);
    }, delay)
  }
}
```
# 节流
当水龙头的水一直往下流，这十分的浪费水，所以我们可以把龙头关小一点，让水一滴一滴往下流，每隔一段时间掉下来一滴水。

节流就是限制一个函数在一段时间内只能执行一次，过了这段时间，在下一段时间又可以执行一次。
## 代码实现（时间戳版）

```js
// 方法一：时间戳
function throttle(fn, delay = 1000) {
  // 记录第一次的调用时间
  var prev = Date.now();
  // 返回闭包函数
  return function () {
    // 保存事件参数
    var args = arguments;
    // 记录现在调用的时间
    var now = Date.now();
    // 如果间隔时间大于等于设置的节流时间
    if (now - prev >= delay) {
      // 执行函数
      fn.apply(this, args);
      // 记录执行完后现在的时间
      prev = Date.now();
    }
  }
}
```
> 当事件触发，第一次会立即执行，后面一直触发时间，函数一定会`delay`时间后执行一次，最后执行一次后不会再执行了
## 代码实现（定时器版）

```js
// 方法二：定时器
function throttle(fn, delay) {
  // 重置定时器
  let timer = null;
  // 返回闭包函数
  return function () {
    // 记录事件参数
    let args = arguments;
    // 如果定时器为空
    if (!timer) {
      // 开启定时器
      timer = setTimeout(() => {
        // 执行函数
        fn.apply(this, args);
        // 函数执行完毕后重置定时器
        timer = null;
      }, delay);
    }
  }
}
```
当第一次触发事件时，肯定不会立即执行函数，而是在`delay`秒后才执行。 之后连续不断触发事件，也会每`delay`秒执行一次。 当最后一次停止触发后，由于定时器的`delay`延迟，可能还会执行一次函数。


